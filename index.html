<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cosmic Love & Fairy Dust</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@300;500&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            font-family: 'Quicksand', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 40px;
        }

        #hint {
            text-align: center;
            color: #ffccff;
            font-size: 16px;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            opacity: 0.7;
            animation: pulseText 3s infinite ease-in-out;
            text-transform: uppercase;
        }

        @keyframes pulseText {

            0%,
            100% {
                opacity: 0.5;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="hint">✨ Catch a floating heart to reveal a secret ✨</div>
    </div>

    <script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION & DATA ---

        const MESSAGES = [
            // Short & Sweet
            "I like you.", "Stay.", "You matter.", "Text me.", "Always you.",
            "Soft heart.", "Mine?", "Call me?", "You glow.", "Don’t overthink.",
            "Forever maybe.", "Still choosing you.", "You feel safe.", "My person.",
            // Magical & Abstract
            "Stardust soul.", "Cosmic vibes.", "Serendipity.", "Infinite.",
            "Dream bigger.", "Pure magic.", "Electric.", "Golden hour.",
            // Affirmations
            "You are enough.", "Keep shining.", "Breathe.", "Trust yourself.",
            "So proud of you.", "Lovely chaos.", "Wild heart.", "Be brave.",
            // Romantic / Flirty
            "Thinking of u.", "Miss you.", "Look at you!", "Secret admirer.",
            "Chemistry.", "Butterflies.", "Eyes on you.", "Wish you were here.",
            "Let's escape.", "Just us.", "Focus on me.", "Catch me.",
            "Make a wish.", "Timing is everything.", "Destiny?"
        ];

        // --- SCENE SETUP ---

        const scene = new THREE.Scene();
        // Add a subtle fog to blend distant objects into the void
        scene.fog = new THREE.FogExp2(0x050510, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Controls (Disabled zoom to keep the vibe intact, but allow rotation)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;

        // --- TEXTURES ---

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(255, 200, 255, 0.5)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createHeartShapeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.translate(64, 64); ctx.scale(1, -1);
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            for (let i = 0; i <= Math.PI * 2; i += 0.05) {
                const x = 16 * Math.pow(Math.sin(i), 3);
                const y = 13 * Math.cos(i) - 5 * Math.cos(2 * i) - 2 * Math.cos(3 * i) - Math.cos(4 * i);
                ctx.lineTo(x * 2, y * 2);
            }
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // High resolution text texture
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            // Large dimensions for crisp text
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Font styling
            ctx.font = "400 90px 'Pacifico', cursive"; // Using the imported font
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Glow effect behind text
            ctx.shadowColor = "#ff00aa";
            ctx.shadowBlur = 30;
            ctx.fillStyle = "#ffffff";
            ctx.fillText(text, 512, 128);

            // Slight stroke for readability
            ctx.strokeStyle = "rgba(255,200,255,0.5)";
            ctx.lineWidth = 2;
            ctx.strokeText(text, 512, 128);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const particleTex = createGlowTexture();
        const heartTex = createHeartShapeTexture();

        // --- OBJECTS ---

        // 1. The Central Heart Nebula (Point Cloud)
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaCount = 3500;
        const nebulaPos = new Float32Array(nebulaCount * 3);
        const nebulaColors = new Float32Array(nebulaCount * 3);
        const nebulaSizes = new Float32Array(nebulaCount);

        const colorPalette = [
            new THREE.Color('#ff0055'), // Red/Pink
            new THREE.Color('#ffcc00'), // Gold
            new THREE.Color('#aa00ff'), // Purple
            new THREE.Color('#00ccff')  // Cyan
        ];

        for (let i = 0; i < nebulaCount; i++) {
            const t = Math.random() * Math.PI * 2;
            // Heart formula
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

            // Scale it down a bit
            x *= 0.8; y *= 0.8;

            // Add 3D volume (randomness in Z and scatter)
            const scatter = Math.random() * 2.5;
            nebulaPos[i * 3] = x + (Math.random() - 0.5) * scatter;
            nebulaPos[i * 3 + 1] = y + (Math.random() - 0.5) * scatter;
            nebulaPos[i * 3 + 2] = (Math.random() - 0.5) * 10; // Z depth

            // Random Colors
            const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            nebulaColors[i * 3] = c.r;
            nebulaColors[i * 3 + 1] = c.g;
            nebulaColors[i * 3 + 2] = c.b;

            // Random Sizes
            nebulaSizes[i] = Math.random() * 1.5;
        }

        nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPos, 3));
        nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
        nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));

        // Custom Shader for twinkling points
        const nebulaMaterial = new THREE.PointsMaterial({
            size: 0.8,
            map: particleTex,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);

        // 2. Floating Clickable Hearts
        const floatingHearts = new THREE.Group();
        scene.add(floatingHearts);

        function spawnFloatingHeart() {
            const mat = new THREE.SpriteMaterial({
                map: heartTex,
                color: new THREE.Color().setHSL(Math.random(), 0.8, 0.7),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(mat);

            // Spawn in a random sphere around the center
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const radius = 25 + Math.random() * 15;

            sprite.position.x = radius * Math.sin(phi) * Math.cos(theta);
            sprite.position.y = radius * Math.sin(phi) * Math.sin(theta);
            sprite.position.z = radius * Math.cos(phi);

            const scale = 1.5 + Math.random();
            sprite.scale.set(scale, scale, 1);

            // Custom data for animation
            sprite.userData = {
                origScale: scale,
                floatSpeed: 0.02 + Math.random() * 0.03,
                offset: Math.random() * 100,
                axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize()
            };

            floatingHearts.add(sprite);
        }

        // Initial batch
        for (let i = 0; i < 30; i++) spawnFloatingHeart();


        // --- INTERACTION SYSTEMS ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const cursorParticles = [];
        const activeMessages = [];

        // Helper: Spawn explosion particles
        function spawnExplosion(pos, color) {
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5
                );

                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: particleTex,
                    color: color,
                    blending: THREE.AdditiveBlending,
                    transparent: true
                }));

                sprite.position.copy(pos);
                sprite.scale.setScalar(0.5 + Math.random() * 0.5);

                scene.add(sprite);

                // Add to global update list (reuse logic from cursor trails)
                cursorParticles.push({
                    mesh: sprite,
                    velocity: vel,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03
                });
            }
        }

        // Mouse Move Logic (Fairy Dust)
        window.addEventListener('mousemove', (e) => {
            // Normalized Coordinates
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // Project point into 3D space near camera for trail
            const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = 25; // Distance from camera to spawn dust
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            // Spawn Dust
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: particleTex,
                color: new THREE.Color().setHSL((Date.now() * 0.001) % 1, 0.8, 0.5),
                transparent: true,
                blending: THREE.AdditiveBlending
            }));
            sprite.position.copy(pos);
            sprite.scale.setScalar(0.5);
            scene.add(sprite);

            cursorParticles.push({
                mesh: sprite,
                velocity: new THREE.Vector3(0, 0, 0), // No initial velocity for trail
                life: 1.0,
                decay: 0.03
            });
        });

        // Click Logic (Reveal Message)
        window.addEventListener('pointerdown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(floatingHearts.children);

            if (intersects.length > 0) {
                const hit = intersects[0].object;

                // 1. Explosion Effect
                spawnExplosion(hit.position, hit.material.color);

                // 2. Show Message
                const msg = MESSAGES[Math.floor(Math.random() * MESSAGES.length)];
                const textTex = createTextTexture(msg);
                const textSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: textTex,
                    transparent: true,
                    depthTest: false // Always show on top
                }));

                textSprite.position.copy(hit.position);
                textSprite.scale.set(8, 2, 1);
                scene.add(textSprite);

                activeMessages.push({
                    mesh: textSprite,
                    life: 3.0, // Seconds on screen
                    origY: hit.position.y
                });

                // 3. Respawn the heart elsewhere
                hit.position.set(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 40
                );
                hit.material.color.setHSL(Math.random(), 0.8, 0.7);
                hit.scale.setScalar(0); // Animate scale up later
                hit.userData.origScale = 1.5 + Math.random();
            }
        });


        // --- POST PROCESSING ---

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        // Unreal Bloom for the glowy magical look
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2; // Intensity
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);


        // --- ANIMATION LOOP ---

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const delta = clock.getDelta(); // Not used heavily but good practice

            controls.update();

            // 1. Animate Nebula (Beat & Rotate)
            // Heartbeat rhythm: fast attack, slow decay
            const beat = Math.pow(Math.sin(time * 3), 6) * 0.1 + 1;
            nebula.scale.setScalar(beat);
            nebula.rotation.z = time * 0.05; // Slow spin

            // 2. Animate Floating Hearts
            floatingHearts.children.forEach(h => {
                // Bobbing motion
                h.position.y += Math.sin(time * 2 + h.userData.offset) * 0.01;
                // Float around center slightly
                h.position.addScaledVector(h.userData.axis, Math.sin(time * 0.5) * 0.02);

                // Pop-in animation if it was just clicked
                if (h.scale.x < h.userData.origScale) {
                    h.scale.addScalar(0.1);
                }
            });

            // 3. Animate Cursor/Explosion Particles
            for (let i = cursorParticles.length - 1; i >= 0; i--) {
                const p = cursorParticles[i];
                p.life -= p.decay;

                // Move
                p.mesh.position.add(p.velocity);

                // Shrink
                p.mesh.scale.multiplyScalar(0.95);
                p.mesh.material.opacity = p.life;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    p.mesh.material.dispose(); // Cleanup memory
                    cursorParticles.splice(i, 1);
                }
            }

            // 4. Animate Messages
            for (let i = activeMessages.length - 1; i >= 0; i--) {
                const m = activeMessages[i];
                m.life -= 0.015; // Fade speed

                // Float Up
                m.mesh.position.y += 0.03;

                // Subtle drift
                m.mesh.position.x += Math.sin(time * 3 + m.origY) * 0.01;

                if (m.life < 1.0) {
                    m.mesh.material.opacity = m.life;
                }

                if (m.life <= 0) {
                    scene.remove(m.mesh);
                    m.mesh.material.map.dispose();
                    m.mesh.material.dispose();
                    activeMessages.splice(i, 1);
                }
            }

            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>