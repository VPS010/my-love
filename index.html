<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Love</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #02020a;
        }

        canvas {
            display: block;
        }

        #hint {
            position: absolute;
            bottom: 35px;
            /* Moved up slightly to make room for footer */
            width: 100%;
            text-align: center;
            color: #ffb7b2;
            font-family: 'Courier New', Courier, monospace;
            opacity: 0.9;
            pointer-events: none;
            font-size: 16px;
            letter-spacing: 4px;
            text-shadow: 0 0 10px #ff0000;
            text-transform: uppercase;
        }

        #progress {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-family: sans-serif;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            opacity: 0.5;
        }

        #footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-family: sans-serif;
            font-size: 12px;
            opacity: 0.7;
            pointer-events: none;
            letter-spacing: 1px;
        }

        @media (max-width: 600px) {
            #footer {
                font-size: 10px;
                opacity: 0.7;
                bottom: 14px;
            }

            #hint {
                font-size: 16px;
                bottom: 48px;
            }
        }
    </style>
</head>

<body>

    <div id="hint">Find and Click all the Small Hearts...</div>
    <div id="progress">0 / 0</div>
    <div id="footer">Made with ❤️ by Vinay</div>

    <script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- UNIQUE MESSAGE LOGIC ---
        const loveNotes = [
            "My Moonlight.",
            "Don’t overthink.",
            "My favorite variable.",
            "You Matter a lot.",
            "Still choosing you.",
            "Wildflower energy.",
            "Forever maybe.",
            "You feel safe.",
            "Soo cuuuuute.",
            "You're my peace.",
            "Miss your smile.",
            "My Paracetamol.",
            "Hold my hand.",
            "Drama queen.",
            "Always you.",
            "Dreaming?.",
            "Innocent soul.",
            "You’re my weakness.",
            "Beautiful soul.",
            "Control that smile.",
            "My sweet headache.",
            "Miss beautiful.",
            "Heart-stealing eyes.",
            "Relax, cutie.",
            "Innocently gorgeous.",
        ];

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        shuffle(loveNotes);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#02020a');
        scene.fog = new THREE.FogExp2(0x02020a, 0.02);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = false;
        controls.enableZoom = true;
        controls.minDistance = 10;
        controls.maxDistance = 60;

        // --- TEXTURES ---
        function createHeartTexture(colorType = 'white') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.translate(64, 64); ctx.scale(1, -1);

            let grad;
            if (colorType === 'red') {
                grad = ctx.createRadialGradient(0, -10, 0, 0, -10, 60);
                grad.addColorStop(0, 'white');
                grad.addColorStop(0.1, '#ff66b2');
                grad.addColorStop(0.5, '#ff0000');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
            } else {
                grad = ctx.createRadialGradient(0, -10, 0, 0, -10, 60);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.4, 'rgba(200, 220, 255, 0.9)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            }

            ctx.fillStyle = grad;
            ctx.beginPath();
            for (let i = 0; i <= Math.PI * 2; i += 0.05) {
                const x = 16 * Math.pow(Math.sin(i), 3);
                const y = 13 * Math.cos(i) - 5 * Math.cos(2 * i) - 2 * Math.cos(3 * i) - Math.cos(4 * i);
                ctx.lineTo(x * 2.5, y * 2.5);
            }
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.translate(32, 32);

            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
            grad.addColorStop(0, 'white');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;

            ctx.beginPath();
            ctx.moveTo(0, -20); ctx.lineTo(4, -4); ctx.lineTo(20, 0);
            ctx.lineTo(4, 4); ctx.lineTo(0, 20); ctx.lineTo(-4, 4);
            ctx.lineTo(-20, 0); ctx.lineTo(-4, -4);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function createTextTexture(text, isFinal = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.font = isFinal ? "bold 110px 'Arial', sans-serif" : "bold 90px 'Arial', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const centerX = 1024;
            const centerY = 256;

            // SHARP TEXT SETTINGS
            if (isFinal) {
                ctx.shadowColor = "#ff0066";
                ctx.shadowBlur = 8;

                ctx.strokeStyle = "#ff0066";
                ctx.lineWidth = 6;
                ctx.strokeText(text, centerX, centerY);

                ctx.fillStyle = "#ffffff";
                ctx.fillText(text, centerX, centerY);
            } else {
                ctx.shadowColor = "#FF00FF";
                ctx.shadowBlur = 2;

                ctx.strokeStyle = "white";
                ctx.lineWidth = 3;
                ctx.strokeText(text, centerX, centerY);

                ctx.fillStyle = "white";
                ctx.fillText(text, centerX, centerY);
            }

            return new THREE.CanvasTexture(canvas);
        }

        const heartTexture = createHeartTexture('white');
        const redHeartTexture = createHeartTexture('red');
        const sparkleTexture = createSparkleTexture();

        // --- CENTRAL RED HEART ---
        const centralGroup = new THREE.Group();
        scene.add(centralGroup);

        const mainHeartGeo = new THREE.PlaneGeometry(9, 9);
        const mainHeartMat = new THREE.MeshBasicMaterial({
            map: redHeartTexture,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const mainHeart = new THREE.Mesh(mainHeartGeo, mainHeartMat);
        mainHeart.position.y = 1;
        mainHeart.userData = { isMain: true };
        centralGroup.add(mainHeart);

        // --- SMALL HEARTS ---
        const heartGroup = new THREE.Group();
        scene.add(heartGroup);
        const heartMat = new THREE.SpriteMaterial({ map: heartTexture, color: 0xffccff, transparent: true, blending: THREE.AdditiveBlending });

        const totalHearts = loveNotes.length;
        document.getElementById('progress').innerText = "0 / " + totalHearts;
        let heartsClicked = 0;

        for (let i = 0; i < totalHearts; i++) {
            const h = new THREE.Sprite(heartMat.clone());
            let x = (Math.random() - 0.5) * 50;
            let y = (Math.random() - 0.5) * 30;
            if (Math.abs(x) < 8) x += 10;

            h.position.set(x, y, (Math.random() - 0.5) * 20);
            h.scale.setScalar(2);
            h.userData = { offset: Math.random() * 100, isSmall: true, id: i };
            heartGroup.add(h);
        }

        // --- PARTICLES & EFFECTS ---
        const cursorParticles = [];
        // REMOVED: rings array for shockwave
        const effects = [];

        function spawnCometParticle(position) {
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: sparkleTexture, color: new THREE.Color(0xaaccff), transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
            sprite.position.copy(position).add(new THREE.Vector3((Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2));
            sprite.scale.setScalar(Math.random() * 0.4 + 0.2);
            scene.add(sprite);
            cursorParticles.push({ mesh: sprite, life: 0.8, velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, 0) });
        }

        // REMOVED: spawnShockwave function

        function spawnFloatingText(pos, text, isFinal = false) {
            const tex = createTextTexture(text, isFinal);
            const textSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
            textSprite.position.copy(pos).add(new THREE.Vector3(0, 1.2, 0));

            textSprite.scale.set(isFinal ? 12 : 8, isFinal ? 3 : 2, 1);

            scene.add(textSprite);

            const pPos = [], pVel = [];
            const pCount = isFinal ? 200 : 40;
            for (let i = 0; i < pCount; i++) {
                pPos.push(pos.x, pos.y, pos.z);
                const theta = Math.random() * Math.PI * 2, phi = Math.random() * Math.PI, spd = Math.random() * (isFinal ? 1.5 : 0.4) + 0.1;
                pVel.push({ x: spd * Math.sin(phi) * Math.cos(theta), y: spd * Math.sin(phi) * Math.sin(theta), z: spd * Math.cos(phi) });
            }
            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));

            // Heart Particles
            const pSys = new THREE.Points(pGeo, new THREE.PointsMaterial({
                size: isFinal ? 2.0 : 1.5,
                map: heartTexture,
                color: 0xff0000,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            }));

            scene.add(pSys);
            effects.push({ text: textSprite, particles: pSys, pVel: pVel, age: 0, isFinal: isFinal });
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let currentCursorPos = new THREE.Vector3(0, 0, 0);
        let lastCursorPos = new THREE.Vector3(0, 0, 0);

        window.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            const dir = new THREE.Vector3(x, y, 0.5).unproject(camera).sub(camera.position).normalize();
            const dist = (10 - camera.position.z) / dir.z;
            currentCursorPos.copy(camera.position).add(dir.multiplyScalar(dist));
        });

        window.addEventListener('click', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const hitsSmall = raycaster.intersectObjects(heartGroup.children);
            if (hitsSmall.length > 0) {
                const hit = hitsSmall[0].object;
                const msg = loveNotes[heartsClicked];

                spawnFloatingText(hit.position, msg);
                // REMOVED: spawnShockwave(hit.position);

                heartGroup.remove(hit);
                heartsClicked++;
                document.getElementById('progress').innerText = heartsClicked + " / " + totalHearts;

                if (heartsClicked === totalHearts) {
                    document.getElementById('hint').innerText = "All hearts collected! CLICK THE BIG HEART NOW!";
                    document.getElementById('hint').style.color = "#ffff00";
                }
                return;
            }

            const hitsMain = raycaster.intersectObject(mainHeart);
            if (hitsMain.length > 0) {
                if (heartsClicked < totalHearts) {
                    const warningMsg = "Dear read all " + (totalHearts - heartsClicked) + " small hearts first!";
                    spawnFloatingText(mainHeart.position.clone().add(new THREE.Vector3(0, 2, 0)), warningMsg);
                    shakeTime = 10;
                } else {
                    spawnFloatingText(mainHeart.position, "Happy Valentine's Day Dear", true);
                    // REMOVED: spawnShockwave(mainHeart.position);
                    mainHeart.visible = false;
                    document.getElementById('hint').style.display = 'none';
                    document.getElementById('progress').style.display = 'none';
                }
            }
        });

        let shakeTime = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.3, 0.1);
        composer.addPass(bloom);
        const clock = new THREE.Clock();

        const nebulaGeo = new THREE.BufferGeometry();
        const countN = 4000;
        const posN = new Float32Array(countN * 3);
        const colsN = new Float32Array(countN * 3);
        const colorsN = [new THREE.Color('#80c7ff'), new THREE.Color('#cdb4db'), new THREE.Color('#bde0fe')];
        for (let i = 0; i < countN; i++) {
            const t = Math.random() * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            posN[i * 3] = x + (Math.random() - 0.5) * 6; posN[i * 3 + 1] = y + (Math.random() - 0.5) * 6; posN[i * 3 + 2] = (Math.random() - 0.5) * 80;
            const c = colorsN[Math.floor(Math.random() * colorsN.length)];
            colsN[i * 3] = c.r; colsN[i * 3 + 1] = c.g; colsN[i * 3 + 2] = c.b;
        }
        nebulaGeo.setAttribute('position', new THREE.BufferAttribute(posN, 3));
        nebulaGeo.setAttribute('color', new THREE.BufferAttribute(colsN, 3));
        const nebula = new THREE.Points(nebulaGeo, new THREE.PointsMaterial({ size: 0.7, map: heartTexture, vertexColors: true, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false }));
        scene.add(nebula);


        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            controls.update();

            if (mainHeart.visible) {
                centralGroup.rotation.y = Math.sin(t * 0.8) * 0.4;
                centralGroup.position.y = Math.sin(t * 1.5) * 0.5;
                if (shakeTime > 0) {
                    centralGroup.position.x = (Math.random() - 0.5) * 1.5;
                    shakeTime--;
                } else {
                    centralGroup.position.x = 0;
                }
            }

            nebula.rotation.z = t * 0.02;

            heartGroup.children.forEach(h => {
                h.position.y += Math.sin(t * 2 + h.userData.offset) * 0.01;
            });

            const distMoved = currentCursorPos.distanceTo(lastCursorPos);
            if (distMoved > 0.01) {
                spawnCometParticle(currentCursorPos);
                if (distMoved > 0.5) spawnCometParticle(new THREE.Vector3().lerpVectors(lastCursorPos, currentCursorPos, 0.5));
                lastCursorPos.copy(currentCursorPos);
            }
            for (let i = cursorParticles.length - 1; i >= 0; i--) {
                const p = cursorParticles[i]; p.life -= 0.05; p.mesh.position.add(p.velocity); p.mesh.scale.multiplyScalar(0.90); p.mesh.material.opacity = p.life;
                if (p.life <= 0) { scene.remove(p.mesh); cursorParticles.splice(i, 1); }
            }

            // REMOVED: Loop updating rings

            for (let i = effects.length - 1; i >= 0; i--) {
                const eff = effects[i]; eff.age++;

                if (!eff.isFinal) {
                    eff.text.position.y += 0.005;
                    if (eff.age > 300) {
                        eff.text.material.opacity -= 0.03;
                    }
                } else {
                    eff.text.material.opacity = 1.0;
                }

                const posAttr = eff.particles.geometry.attributes.position;
                for (let j = 0; j < eff.pVel.length; j++) {
                    posAttr.array[j * 3] += eff.pVel[j].x; posAttr.array[j * 3 + 1] += eff.pVel[j].y; posAttr.array[j * 3 + 2] += eff.pVel[j].z;
                    eff.pVel[j].x *= 0.95; eff.pVel[j].y *= 0.95; eff.pVel[j].z *= 0.95;
                }
                posAttr.needsUpdate = true;

                eff.particles.material.opacity = 1 - (eff.age / 300);

                if (eff.age > 350) {
                    scene.remove(eff.particles);
                    if (!eff.isFinal) {
                        scene.remove(eff.text);
                        effects.splice(i, 1);
                    }
                }
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>

</body>

</html>